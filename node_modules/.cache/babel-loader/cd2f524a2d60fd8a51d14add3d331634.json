{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports[\"default\"] = instrument;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = void 0;\n\nvar _difference = _interopRequireDefault(require(\"lodash/difference\"));\n\nvar _union = _interopRequireDefault(require(\"lodash/union\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _symbolObservable = _interopRequireDefault(require(\"symbol-observable\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nexports.ActionTypes = ActionTypes;\nvar isChrome = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\n\nvar ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit, // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace) {\n    if (!(0, _isPlainObject[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    var stack;\n\n    if (trace) {\n      var extraFrames = 0;\n\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit;\n\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || traceLimit && Error.stackTraceLimit > traceLimit) {\n          if (stack != null) {\n            var frames = stack.split('\\n');\n\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nexports.ActionCreators = ActionCreators;\nvar INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nexports.INIT_ACTION = INIT_ACTION;\n\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var _actionId = stagedActionIds[i];\n    var _action = actionsById[_actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(_actionId) > -1;\n    var entry = void 0;\n\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, _action, previousState, shouldCatchErrors);\n      }\n    }\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action, trace, traceLimit, // eslint-disable-next-line @typescript-eslint/ban-types\ntoExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\n\nfunction isArray(nextLiftedState) {\n  return Array.isArray(nextLiftedState);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n        monitorState = _ref.monitorState,\n        actionsById = _ref.actionsById,\n        nextActionId = _ref.nextActionId,\n        stagedActionIds = _ref.stagedActionIds,\n        skippedActionIds = _ref.skippedActionIds,\n        committedState = _ref.committedState,\n        currentStateIndex = _ref.currentStateIndex,\n        computedStates = _ref.computedStates,\n        isLocked = _ref.isLocked,\n        isPaused = _ref.isPaused;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _objectSpread({}, actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(shouldInit) {\n      var computedState;\n\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n\n        stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n        nextActionId++;\n      }\n\n      return {\n        monitorState: monitorState,\n        actionsById: _objectSpread(_objectSpread({}, actionsById), {}, _defineProperty({}, nextActionId - 1, liftAction({\n          type: options.pauseActionType\n        }))),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(_toConsumableArray(computedStates.slice(0, stagedActionIds.length - 1)), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var _actionId2 = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n\n            actionsById[_actionId2] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId3 = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId3);\n\n            if (index === -1) {\n              skippedActionIds = [_actionId3].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId3;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId3);\n            break;\n          }\n\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = (0, _difference[\"default\"])(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union[\"default\"])(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference[\"default\"])(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId4 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId4); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n\n            var diff = idx - newIdx;\n\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1)));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx)));\n              minInvalidatedStateIndex = idx;\n            }\n\n            break;\n          }\n\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n\n            break;\n          }\n\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\n\n\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var lastDefinedState;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n\n    return lastDefinedState;\n  }\n\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return _objectSpread(_objectSpread({}, liftedStore), {}, _defineProperty({\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _symbolObservable[\"default\"], function () {\n    return _objectSpread(_objectSpread({}, liftedStore[_symbolObservable[\"default\"]]()), {}, _defineProperty({\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _symbolObservable[\"default\"], function () {\n      return this;\n    }));\n  }));\n}\n/**\n * Redux instrumentation store enhancer.\n */\n\n\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r[\"default\"] === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n\n          throw new Error('Expected the reducer to be a function.');\n        }\n\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n\n      var liftedStore = createStore(liftReducer(reducer));\n\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}","map":{"version":3,"sources":["../src/instrument.ts"],"names":["ActionTypes","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","isChromeOrNode","process","ActionCreators","performAction","action","extraFrames","stack","trace","error","Error","traceLimit","prevStackTraceLimit","frames","type","timestamp","Date","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","active","start","end","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","INIT_ACTION","nextState","reducer","nextError","err","setTimeout","console","state","computeWithTryCatch","minInvalidatedStateIndex","computedStates","stagedActionIds","nextComputedStates","i","actionsById","previousEntry","previousState","shouldSkip","skippedActionIds","entry","shouldCatchErrors","computeNextEntry","Array","initialLiftedState","monitorState","monitorReducer","nextActionId","liftAction","committedState","currentStateIndex","isLocked","options","isPaused","liftedState","excess","idsToDelete","computedState","liftedAction","pauseActionType","maxAge","recomputeStates","commitExcessActions","computePausedAction","actionIds","Math","idx","newIdx","count","diff","isArray","unliftState","liftedStore","lastDefinedState","dispatch","getState","replaceReducer","liftReducer","$$observable","subscribe","observer","observeState","unsubscribe","r","liftReducerWith","createStore","unliftStore"],"mappings":";;;;;;;;;;;;AAAA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,sBAAA,CAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWO,IAAMA,WAAW,GAAG;AACzBC,EAAAA,cAAc,EADW,gBAAA;AAEzBC,EAAAA,KAAK,EAFoB,OAAA;AAGzBC,EAAAA,QAAQ,EAHiB,UAAA;AAIzBC,EAAAA,MAAM,EAJmB,QAAA;AAKzBC,EAAAA,KAAK,EALoB,OAAA;AAMzBC,EAAAA,aAAa,EANY,eAAA;AAOzBC,EAAAA,kBAAkB,EAPO,oBAAA;AAQzBC,EAAAA,aAAa,EARY,eAAA;AASzBC,EAAAA,cAAc,EATW,gBAAA;AAUzBC,EAAAA,cAAc,EAVW,gBAAA;AAWzBC,EAAAA,YAAY,EAXa,cAAA;AAYzBC,EAAAA,YAAY,EAZa,cAAA;AAazBC,EAAAA,eAAe,EAAE;AAbQ,CAApB;;AAgBP,IAAMC,QAAQ,GACZ,CAAA,OAAA,MAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,MAAA,CAAA,MAAA,QAAA,KACC,OAAQC,MAAD,CAAP,MAAA,KAAA,WAAA,IAEE,OAAOA,MAAM,CAAb,OAAA,KAAA,WAAA,IACEA,MAAM,CAAP,OAACA,CAAD,IAACA,KALP,UACE,CADF;AAQA,IAAMC,cAAc,GAClBF,QAAQ,IACP,OAAA,OAAA,KAAA,WAAA,IACCG,OAAO,CADR,OAAA,IAECA,OAAO,CAAPA,OAAAA,CAAAA,IAAAA,KAJJ,MAAA;AA4FA;;;;AAGO,IAAMC,cAAc,GAAG;AAC5BC,EAAAA,aAD4B,EAAA,SAAA,aAAA,CAAA,MAAA,EAAA,KAAA,EAAA,UAAA,EAK1B;AAL0B,EAAA,kBAAA,EAO1B;AACA,QAAI,CAAC,CAAA,GAAA,cAAA,CAAA,SAAA,CAAA,EAAL,MAAK,CAAL,EAA4B;AAC1B,YAAM,IAAA,KAAA,CACJ,oCADF,0CAAM,CAAN;AAID;;AAED,QAAI,OAAOC,MAAM,CAAb,IAAA,KAAJ,WAAA,EAAwC;AACtC,YAAM,IAAA,KAAA,CACJ,wDADF,iCAAM,CAAN;AAID;;AAED,QAAA,KAAA;;AACA,QAAA,KAAA,EAAW;AACT,UAAIC,WAAW,GAAf,CAAA;;AACA,UAAI,OAAA,KAAA,KAAJ,UAAA,EAAiC;AAC/BC,QAAAA,KAAK,GAAGC,KAAK,CAAbD,MAAa,CAAbA;AADF,OAAA,MAEO;AACL,YAAME,KAAK,GAAGC,KAAd,EAAA;AACA,YAAA,mBAAA;;AACA,YAAIA,KAAK,CAALA,iBAAAA,IAAJ,cAAA,EAA+C;AAC7C;AACA,cAAIC,UAAU,IAAID,KAAK,CAALA,eAAAA,GAAlB,UAAA,EAAsD;AACpDE,YAAAA,mBAAmB,GAAGF,KAAK,CAA3BE,eAAAA;AACAF,YAAAA,KAAK,CAALA,eAAAA,GAAAA,UAAAA;AACD;;AACDA,UAAAA,KAAK,CAALA,iBAAAA,CAAAA,KAAAA,EAAAA,kBAAAA;AANF,SAAA,MAOO;AACLJ,UAAAA,WAAW,GAAXA,CAAAA;AACD;;AACDC,QAAAA,KAAK,GAAGE,KAAK,CAAbF,KAAAA;AACA,YAAA,mBAAA,EAAyBG,KAAK,CAALA,eAAAA,GAAAA,mBAAAA;;AACzB,YACEJ,WAAW,IACX,OAAOI,KAAK,CAAZ,eAAA,KADAJ,QAAAA,IAECK,UAAU,IAAID,KAAK,CAALA,eAAAA,GAHjB,UAAA,EAIE;AACA,cAAIH,KAAK,IAAT,IAAA,EAAmB;AACjB,gBAAMM,MAAM,GAAGN,KAAK,CAALA,KAAAA,CAAf,IAAeA,CAAf;;AACA,gBAAII,UAAU,IAAIE,MAAM,CAANA,MAAAA,GAAlB,UAAA,EAA8C;AAC5CN,cAAAA,KAAK,GAAGM,MAAM,CAANA,KAAAA,CAAAA,CAAAA,EAGJF,UAAU,GAAVA,WAAAA,IAEGE,MAAM,CAANA,CAAM,CAANA,CAAAA,UAAAA,CAAAA,OAAAA,IAAAA,CAAAA,GALCA,CAGJF,CAHIE,EAAAA,IAAAA,CAARN,IAAQM,CAARN;AAQD;AACF;AACF;AACF;AACF;;AAED,WAAO;AACLO,MAAAA,IAAI,EAAE7B,WAAW,CADZ,cAAA;AAELoB,MAAAA,MAAM,EAFD,MAAA;AAGLU,MAAAA,SAAS,EAAEC,IAAI,CAHV,GAGMA,EAHN;AAILT,MAAAA,KAAK,EAALA;AAJK,KAAP;AAhE0B,GAAA;AAwE5BU,EAAAA,KAxE4B,EAAA,SAAA,KAAA,GAwEP;AACnB,WAAO;AAAEH,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,KAAA;AAA2B8B,MAAAA,SAAS,EAAEC,IAAI,CAAJA,GAAAA;AAAtC,KAAP;AAzE0B,GAAA;AA4E5BE,EAAAA,QA5E4B,EAAA,SAAA,QAAA,GA4ED;AACzB,WAAO;AAAEJ,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,QAAA;AAA8B8B,MAAAA,SAAS,EAAEC,IAAI,CAAJA,GAAAA;AAAzC,KAAP;AA7E0B,GAAA;AAgF5BG,EAAAA,MAhF4B,EAAA,SAAA,MAAA,GAgFL;AACrB,WAAO;AAAEL,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,MAAA;AAA4B8B,MAAAA,SAAS,EAAEC,IAAI,CAAJA,GAAAA;AAAvC,KAAP;AAjF0B,GAAA;AAoF5BI,EAAAA,KApF4B,EAAA,SAAA,KAAA,GAoFP;AACnB,WAAO;AAAEN,MAAAA,IAAI,EAAE7B,WAAW,CAACK;AAApB,KAAP;AArF0B,GAAA;AAwF5B+B,EAAAA,YAxF4B,EAAA,SAAA,YAAA,CAAA,EAAA,EAwFW;AACrC,WAAO;AAAEP,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,aAAA;AAAmCqC,MAAAA,EAAE,EAAFA;AAAnC,KAAP;AAzF0B,GAAA;AA4F5BC,EAAAA,gBA5F4B,EAAA,SAAA,gBAAA,CAAA,KAAA,EAAA,GAAA,EAgGF;AAAA,QADxBC,MACwB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADf,IACe;AACxB,WAAO;AAAEV,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,kBAAA;AAAwCwC,MAAAA,KAAK,EAA7C,KAAA;AAA+CC,MAAAA,GAAG,EAAlD,GAAA;AAAoDF,MAAAA,MAAM,EAANA;AAApD,KAAP;AAjG0B,GAAA;AAoG5BG,EAAAA,aApG4B,EAAA,SAAA,aAAA,CAAA,QAAA,EAAA,cAAA,EAoG2C;AACrE,WAAO;AAAEb,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,cAAA;AAAoC2C,MAAAA,QAAQ,EAA5C,QAAA;AAA8CC,MAAAA,cAAc,EAAdA;AAA9C,KAAP;AArG0B,GAAA;AAwG5BC,EAAAA,WAxG4B,EAAA,SAAA,WAAA,CAAA,KAAA,EAwGkB;AAC5C,WAAO;AAAEhB,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,aAAA;AAAmC8C,MAAAA,KAAK,EAALA;AAAnC,KAAP;AAzG0B,GAAA;AA4G5BC,EAAAA,YA5G4B,EAAA,SAAA,YAAA,CAAA,QAAA,EA4GuB;AACjD,WAAO;AAAElB,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,cAAA;AAAoC2C,MAAAA,QAAQ,EAARA;AAApC,KAAP;AA7G0B,GAAA;AAgH5BK,EAAAA,WAhH4B,EAAA,SAAA,WAAA,CAAA,eAAA,EAAA,WAAA,EAmHa;AACvC,WAAO;AAAEnB,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,YAAA;AAAkCiD,MAAAA,eAAe,EAAjD,eAAA;AAAmDC,MAAAA,WAAW,EAAXA;AAAnD,KAAP;AApH0B,GAAA;AAuH5BC,EAAAA,WAvH4B,EAAA,SAAA,WAAA,CAAA,MAAA,EAuHoB;AAC9C,WAAO;AAAEtB,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,YAAA;AAAkCoD,MAAAA,MAAM,EAANA;AAAlC,KAAP;AAxH0B,GAAA;AA2H5BC,EAAAA,cA3H4B,EAAA,SAAA,cAAA,CAAA,MAAA,EA2H0B;AACpD,WAAO;AAAExB,MAAAA,IAAI,EAAE7B,WAAW,CAAnB,eAAA;AAAqCoD,MAAAA,MAAM,EAANA;AAArC,KAAP;AACD;AA7H2B,CAAvB;;AAgIA,IAAME,WAAW,GAAG;AAAEzB,EAAAA,IAAI,EAAE;AAAR,CAApB;AAEP;;;;;;AAGA,SAAA,mBAAA,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAIE;AACA,MAAI0B,SAAS,GAAb,KAAA;AACA,MAAA,SAAA;;AACA,MAAI;AACFA,IAAAA,SAAS,GAAGC,OAAO,CAAA,KAAA,EAAnBD,MAAmB,CAAnBA;AADF,GAAA,CAEE,OAAA,GAAA,EAAY;AACZE,IAAAA,SAAS,GAAGC,GAAG,CAAfD,QAAYC,EAAZD;;AACA,QAAA,QAAA,EAAc;AACZ;AACAE,MAAAA,UAAU,CAAC,YAAM;AACf,cAAA,GAAA;AADFA,OAAU,CAAVA;AAFF,KAAA,MAKO;AACLC,MAAAA,OAAO,CAAPA,KAAAA,CADK,GACLA,EADK,CACe;AACrB;AACF;;AAED,SAAO;AACLC,IAAAA,KAAK,EADA,SAAA;AAELrC,IAAAA,KAAK,EAAEiC;AAFF,GAAP;AAID;AAED;;;;;AAGA,SAAA,gBAAA,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,iBAAA,EAKE;AACA,MAAI,CAAJ,iBAAA,EAAwB;AACtB,WAAO;AAAEI,MAAAA,KAAK,EAAEL,OAAO,CAAA,KAAA,EAAA,MAAA;AAAhB,KAAP;AACD;;AACD,SAAOM,mBAAmB,CAAA,OAAA,EAAA,MAAA,EAA1B,KAA0B,CAA1B;AACD;AAED;;;;;AAGA,SAAA,eAAA,CAAA,cAAA,EAAA,wBAAA,EAAA,OAAA,EAAA,cAAA,EAAA,WAAA,EAAA,eAAA,EAAA,gBAAA,EAAA,iBAAA,EASE;AACA;AACA;AACA,MACE,CAAA,cAAA,IACAC,wBAAwB,KAAK,CAD7B,CAAA,IAECA,wBAAwB,IAAIC,cAAc,CAA1CD,MAAAA,IACCC,cAAc,CAAdA,MAAAA,KAA0BC,eAAe,CAJ7C,MAAA,EAKE;AACA,WAAA,cAAA;AACD;;AAED,MAAMC,kBAAkB,GAAGF,cAAc,CAAdA,KAAAA,CAAAA,CAAAA,EAA3B,wBAA2BA,CAA3B;;AACA,OAAK,IAAIG,CAAC,GAAV,wBAAA,EAAuCA,CAAC,GAAGF,eAAe,CAA1D,MAAA,EAAmEE,CAAnE,EAAA,EAAwE;AACtE,QAAMxB,SAAQ,GAAGsB,eAAe,CAAhC,CAAgC,CAAhC;AACA,QAAM7C,OAAM,GAAGgD,WAAW,CAAXA,SAAW,CAAXA,CAAf,MAAA;AAEA,QAAMC,aAAa,GAAGH,kBAAkB,CAACC,CAAC,GAA1C,CAAwC,CAAxC;AACA,QAAMG,aAAa,GAAGD,aAAa,GAAGA,aAAa,CAAhB,KAAA,GAAnC,cAAA;AAEA,QAAME,UAAU,GAAGC,gBAAgB,CAAhBA,OAAAA,CAAAA,SAAAA,IAAqC,CAAxD,CAAA;AACA,QAAIC,KAAK,GAAA,KAAT,CAAA;;AACA,QAAA,UAAA,EAAgB;AACdA,MAAAA,KAAK,GAALA,aAAAA;AADF,KAAA,MAEO;AACL,UAAIC,iBAAiB,IAAjBA,aAAAA,IAAsCL,aAAa,CAAvD,KAAA,EAA+D;AAC7DI,QAAAA,KAAK,GAAG;AACNZ,UAAAA,KAAK,EADC,aAAA;AAENrC,UAAAA,KAAK,EAAE;AAFD,SAARiD;AADF,OAAA,MAKO;AACLA,QAAAA,KAAK,GAAGE,gBAAgB,CAAA,OAAA,EAAA,OAAA,EAAA,aAAA,EAAxBF,iBAAwB,CAAxBA;AAMD;AACF;;AACDP,IAAAA,kBAAkB,CAAlBA,IAAAA,CAAAA,KAAAA;AACD;;AAED,SAAA,kBAAA;AACD;AAED;;;;;AAGO,SAAA,UAAA,CAAA,MAAA,EAAA,KAAA,EAAA,UAAA,EAIL;AAJK,kBAAA,EAML;AACA,SAAOhD,cAAc,CAAdA,aAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,UAAAA,EAAP,kBAAOA,CAAP;AAMD;;AAED,SAAA,OAAA,CAAA,eAAA,EAEmC;AACjC,SAAO0D,KAAK,CAALA,OAAAA,CAAP,eAAOA,CAAP;AACD;AAeD;;;;;AAGO,SAAA,eAAA,CAAA,OAAA,EAAA,qBAAA,EAAA,cAAA,EAAA,OAAA,EAUuE;AAC5E,MAAMC,kBAAmD,GAAG;AAC1DC,IAAAA,YAAY,EAAEC,cAAc,CAAA,SAAA,EAD8B,EAC9B,CAD8B;AAE1DC,IAAAA,YAAY,EAF8C,CAAA;AAG1DZ,IAAAA,WAAW,EAAE;AAAE,SAAGa,UAAU,CAAA,WAAA;AAAf,KAH6C;AAI1DhB,IAAAA,eAAe,EAAE,CAJyC,CAIzC,CAJyC;AAK1DO,IAAAA,gBAAgB,EAL0C,EAAA;AAM1DU,IAAAA,cAAc,EAN4C,qBAAA;AAO1DC,IAAAA,iBAAiB,EAPyC,CAAA;AAQ1DnB,IAAAA,cAAc,EAR4C,EAAA;AAS1DoB,IAAAA,QAAQ,EAAEC,OAAO,CAAPA,iBAAAA,KATgD,IAAA;AAU1DC,IAAAA,QAAQ,EAAED,OAAO,CAAPA,mBAAAA,KAAgC;AAVgB,GAA5D;AAaA;;;;AAGA,SAAO,UAAA,WAAA,EAAA,YAAA,EAG+B;AAAA,QAAA,IAAA,GAYhCE,WAAW,IAZqB,kBAAA;AAAA,QAElCT,YAFkC,GAAA,IAAA,CAAA,YAAA;AAAA,QAGlCV,WAHkC,GAAA,IAAA,CAAA,WAAA;AAAA,QAIlCY,YAJkC,GAAA,IAAA,CAAA,YAAA;AAAA,QAKlCf,eALkC,GAAA,IAAA,CAAA,eAAA;AAAA,QAMlCO,gBANkC,GAAA,IAAA,CAAA,gBAAA;AAAA,QAOlCU,cAPkC,GAAA,IAAA,CAAA,cAAA;AAAA,QAQlCC,iBARkC,GAAA,IAAA,CAAA,iBAAA;AAAA,QASlCnB,cATkC,GAAA,IAAA,CAAA,cAAA;AAAA,QAUlCoB,QAVkC,GAAA,IAAA,CAAA,QAAA;AAAA,QAWlCE,QAXkC,GAAA,IAAA,CAAA,QAAA;;AAcpC,QAAI,CAAJ,WAAA,EAAkB;AAChB;AACAlB,MAAAA,WAAW,GAAA,aAAA,CAAA,EAAA,EAAXA,WAAW,CAAXA;AACD;;AAED,aAAA,mBAAA,CAAA,CAAA,EAAwC;AACtC;AACA,UAAIoB,MAAM,GAAV,CAAA;AACA,UAAIC,WAAW,GAAGxB,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAyBuB,MAAM,GAAjD,CAAkBvB,CAAlB;;AAEA,WAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGsB,WAAW,CAA/B,MAAA,EAAwCtB,CAAxC,EAAA,EAA6C;AAC3C,YAAIH,cAAc,CAACG,CAAC,GAAhBH,CAAc,CAAdA,CAAJ,KAAA,EAAiC;AAC/B;AACAwB,UAAAA,MAAM,GAANA,CAAAA;AACAC,UAAAA,WAAW,GAAGxB,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAyBuB,MAAM,GAA7CC,CAAcxB,CAAdwB;AACA;AAJF,SAAA,MAKO;AACL,iBAAOrB,WAAW,CAACqB,WAAW,CAA9B,CAA8B,CAAZ,CAAlB;AACD;AACF;;AAEDjB,MAAAA,gBAAgB,GAAG,gBAAgB,CAAhB,MAAA,CACjB,UAAA,EAAA,EAAA;AAAA,eAAQiB,WAAW,CAAXA,OAAAA,CAAAA,EAAAA,MAA4B,CAApC,CAAA;AADFjB,OAAmB,CAAnBA;AAGAP,MAAAA,eAAe,GAAA,CAAA,CAAA,EAAA,MAAA,CAAA,kBAAA,CAAUA,eAAe,CAAfA,KAAAA,CAAsBuB,MAAM,GAArDvB,CAAyBA,CAAV,CAAA,CAAfA;AACAiB,MAAAA,cAAc,GAAGlB,cAAc,CAAdA,MAAc,CAAdA,CAAjBkB,KAAAA;AACAlB,MAAAA,cAAc,GAAGA,cAAc,CAAdA,KAAAA,CAAjBA,MAAiBA,CAAjBA;AACAmB,MAAAA,iBAAiB,GACfA,iBAAiB,GAAjBA,MAAAA,GAA6BA,iBAAiB,GAA9CA,MAAAA,GADFA,CAAAA;AAED;;AAED,aAAA,mBAAA,CAAA,UAAA,EAEmC;AACjC,UAAA,aAAA;;AACA,UAAA,UAAA,EAAgB;AACdO,QAAAA,aAAa,GAAG1B,cAAc,CAA9B0B,iBAA8B,CAA9BA;AACAZ,QAAAA,YAAY,GAAGC,cAAc,CAAA,YAAA,EAA7BD,YAA6B,CAA7BA;AAFF,OAAA,MAMO;AACLY,QAAAA,aAAa,GAAGf,gBAAgB,CAAA,OAAA,EAE7BgB,YAAD,CAF8B,MAAA,EAG9B3B,cAAc,CAAdA,iBAAc,CAAdA,CAH8B,KAAA,EAAhC0B,KAAgC,CAAhCA;AAMD;;AACD,UAAI,CAACL,OAAO,CAAR,eAAA,IAA4BL,YAAY,KAA5C,CAAA,EAAoD;AAClD,eAAO;AACLF,UAAAA,YAAY,EADP,YAAA;AAELV,UAAAA,WAAW,EAAE;AAAE,eAAGa,UAAU,CAAA,WAAA;AAAf,WAFR;AAGLD,UAAAA,YAAY,EAHP,CAAA;AAILf,UAAAA,eAAe,EAAE,CAJZ,CAIY,CAJZ;AAKLO,UAAAA,gBAAgB,EALX,EAAA;AAMLU,UAAAA,cAAc,EAAEQ,aAAa,CANxB,KAAA;AAOLP,UAAAA,iBAAiB,EAPZ,CAAA;AAQLnB,UAAAA,cAAc,EAAE,CARX,aAQW,CARX;AASLoB,UAAAA,QAAQ,EATH,QAAA;AAULE,UAAAA,QAAQ,EAAE;AAVL,SAAP;AAYD;;AACD,UAAA,UAAA,EAAgB;AACd,YAAIH,iBAAiB,KAAKlB,eAAe,CAAfA,MAAAA,GAA1B,CAAA,EAAsD;AACpDkB,UAAAA,iBAAiB;AAClB;;AACDlB,QAAAA,eAAe,GAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,eAAA,CAAA,EAAA,CAAfA,YAAe,CAAA,CAAfA;AACAe,QAAAA,YAAY;AACb;;AACD,aAAO;AACLF,QAAAA,YAAY,EADP,YAAA;AAELV,QAAAA,WAAW,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,WAAA,CAAA,EAAA,EAAA,EAAA,eAAA,CAAA,EAAA,EAERY,YAAY,GAFJ,CAAA,EAEWC,UAAU,CAAC;AAC7BpD,UAAAA,IAAI,EAAEwD,OAAO,CAACO;AADe,SAAD,CAFrB,CAAA,CAFN;AAQLZ,QAAAA,YAAY,EARP,YAAA;AASLf,QAAAA,eAAe,EATV,eAAA;AAULO,QAAAA,gBAAgB,EAVX,gBAAA;AAWLU,QAAAA,cAAc,EAXT,cAAA;AAYLC,QAAAA,iBAAiB,EAZZ,iBAAA;AAaLnB,QAAAA,cAAc,EAAA,GAAA,MAAA,CAAA,kBAAA,CACTA,cAAc,CAAdA,KAAAA,CAAAA,CAAAA,EAAwBC,eAAe,CAAfA,MAAAA,GADf,CACTD,CADS,CAAA,EAAA,CAbT,aAaS,CAAA,CAbT;AAiBLoB,QAAAA,QAAQ,EAjBH,QAAA;AAkBLE,QAAAA,QAAQ,EAAE;AAlBL,OAAP;AApFkC,KAAA,CA0GpC;AACA;AACA;;;AACA,QAAIvB,wBAAwB,GA7GQ,CA6GpC,CA7GoC,CA+GpC;;AACA,QAAI8B,MAAM,GAAGR,OAAO,CAApB,MAAA;AACA,QAAI,OAAA,MAAA,KAAJ,UAAA,EACEQ,MAAM,GAAGA,MAAM,CAAA,YAAA,EAAfA,WAAe,CAAfA;;AAEF,QAAI,2BAAA,IAAA,CAAgCF,YAAY,CAAhD,IAAI,CAAJ,EAAwD;AACtD,UAAIN,OAAO,CAAPA,eAAAA,KAAJ,KAAA,EAAuC;AACrCjB,QAAAA,WAAW,GAAG;AAAE,aAAGa,UAAU,CAAA,WAAA;AAAf,SAAdb;AACAY,QAAAA,YAAY,GAAZA,CAAAA;AACAf,QAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,QAAAA,gBAAgB,GAAhBA,EAAAA;AACAU,QAAAA,cAAc,GACZlB,cAAc,CAAdA,MAAAA,KAAAA,CAAAA,GAAAA,qBAAAA,GAEIA,cAAc,CAAdA,iBAAc,CAAdA,CAHNkB,KAAAA;AAIAC,QAAAA,iBAAiB,GAAjBA,CAAAA;AACAnB,QAAAA,cAAc,GAAdA,EAAAA;AAXoD,OAAA,CActD;;;AACAD,MAAAA,wBAAwB,GAAxBA,CAAAA;;AAEA,UAAI8B,MAAM,IAAI5B,eAAe,CAAfA,MAAAA,GAAd,MAAA,EAA+C;AAC7C;AACAD,QAAAA,cAAc,GAAG8B,eAAe,CAAA,cAAA,EAAA,wBAAA,EAAA,OAAA,EAAA,cAAA,EAAA,WAAA,EAAA,eAAA,EAAA,gBAAA,EAQ9BT,OAAO,CARTrB,iBAAgC,CAAhCA;AAWA+B,QAAAA,mBAAmB,CAAC9B,eAAe,CAAfA,MAAAA,GAbyB,MAa1B,CAAnB8B,CAb6C,CAe7C;;AACAhC,QAAAA,wBAAwB,GAAxBA,QAAAA;AACD;AAlCH,KAAA,MAmCO;AACL,cAAQ4B,YAAY,CAApB,IAAA;AACE,aAAK3F,WAAW,CAAhB,cAAA;AAAiC;AAC/B,gBAAA,QAAA,EAAc,OAAOuF,WAAW,IAAlB,kBAAA;AACd,gBAAA,QAAA,EAAc,OAAOS,mBAFU,EAEjB,CAFiB,CAI/B;;AACA,gBAAIH,MAAM,IAAI5B,eAAe,CAAfA,MAAAA,IAAd,MAAA,EAAgD;AAC9C8B,cAAAA,mBAAmB,CAAC9B,eAAe,CAAfA,MAAAA,GAAAA,MAAAA,GAApB8B,CAAmB,CAAnBA;AACD;;AAED,gBAAIZ,iBAAiB,KAAKlB,eAAe,CAAfA,MAAAA,GAA1B,CAAA,EAAsD;AACpDkB,cAAAA,iBAAiB;AAClB;;AACD,gBAAMxC,UAAQ,GAAGqC,YAZc,EAY/B,CAZ+B,CAa/B;AACA;;;AACAZ,YAAAA,WAAW,CAAXA,UAAW,CAAXA,GAAAA,YAAAA;AACAH,YAAAA,eAAe,GAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,eAAA,CAAA,EAAA,CAhBgB,UAgBhB,CAAA,CAAfA,CAhB+B,CAiB/B;;AACAF,YAAAA,wBAAwB,GAAGE,eAAe,CAAfA,MAAAA,GAA3BF,CAAAA;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,KAAA;AAAwB;AACtB;AACAoE,YAAAA,WAAW,GAAG;AAAE,iBAAGa,UAAU,CAAA,WAAA;AAAf,aAAdb;AACAY,YAAAA,YAAY,GAAZA,CAAAA;AACAf,YAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,YAAAA,gBAAgB,GAAhBA,EAAAA;AACAU,YAAAA,cAAc,GAAdA,qBAAAA;AACAC,YAAAA,iBAAiB,GAAjBA,CAAAA;AACAnB,YAAAA,cAAc,GAAdA,EAAAA;AACA;AACD;;AACD,aAAKhE,WAAW,CAAhB,MAAA;AAAyB;AACvB;AACA;AACAoE,YAAAA,WAAW,GAAG;AAAE,iBAAGa,UAAU,CAAA,WAAA;AAAf,aAAdb;AACAY,YAAAA,YAAY,GAAZA,CAAAA;AACAf,YAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,YAAAA,gBAAgB,GAAhBA,EAAAA;AACAU,YAAAA,cAAc,GAAGlB,cAAc,CAAdA,iBAAc,CAAdA,CAAjBkB,KAAAA;AACAC,YAAAA,iBAAiB,GAAjBA,CAAAA;AACAnB,YAAAA,cAAc,GAAdA,EAAAA;AACA;AACD;;AACD,aAAKhE,WAAW,CAAhB,QAAA;AAA2B;AACzB;AACA;AACAoE,YAAAA,WAAW,GAAG;AAAE,iBAAGa,UAAU,CAAA,WAAA;AAAf,aAAdb;AACAY,YAAAA,YAAY,GAAZA,CAAAA;AACAf,YAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,YAAAA,gBAAgB,GAAhBA,EAAAA;AACAW,YAAAA,iBAAiB,GAAjBA,CAAAA;AACAnB,YAAAA,cAAc,GAAdA,EAAAA;AACA;AACD;;AACD,aAAKhE,WAAW,CAAhB,aAAA;AAAgC;AAC9B;AACA;AAF8B,gBAGlB2C,UAHkB,GAGLgD,YAHK,CAAA,EAAA;AAI9B,gBAAM7C,KAAK,GAAG0B,gBAAgB,CAAhBA,OAAAA,CAAd,UAAcA,CAAd;;AACA,gBAAI1B,KAAK,KAAK,CAAd,CAAA,EAAkB;AAChB0B,cAAAA,gBAAgB,GAAA,CAAA,UAAA,EAAA,MAAA,CAAA,kBAAA,CAAhBA,gBAAgB,CAAA,CAAhBA;AADF,aAAA,MAEO;AACLA,cAAAA,gBAAgB,GAAG,gBAAgB,CAAhB,MAAA,CAAwB,UAAA,EAAA,EAAA;AAAA,uBAAQnC,EAAE,KAAV,UAAA;AAA3CmC,eAAmB,CAAnBA;AAR4B,aAAA,CAU9B;;;AACAT,YAAAA,wBAAwB,GAAGE,eAAe,CAAfA,OAAAA,CAA3BF,UAA2BE,CAA3BF;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,kBAAA;AAAqC;AACnC;AACA;AAFmC,gBAG3BwC,KAH2B,GAGJmD,YAHI,CAAA,KAAA;AAAA,gBAGpBlD,GAHoB,GAGJkD,YAHI,CAAA,GAAA;AAAA,gBAGfpD,MAHe,GAGJoD,YAHI,CAAA,MAAA;AAInC,gBAAMM,SAAS,GAAf,EAAA;;AACA,iBAAK,IAAI9B,CAAC,GAAV,KAAA,EAAoBA,CAAC,GAArB,GAAA,EAA6BA,CAA7B,EAAA,EAAA;AAAkC8B,cAAAA,SAAS,CAATA,IAAAA,CAAAA,CAAAA;AAAlC;;AACA,gBAAA,MAAA,EAAY;AACVzB,cAAAA,gBAAgB,GAAG,CAAA,GAAA,WAAA,CAAA,SAAA,CAAA,EAAA,gBAAA,EAAnBA,SAAmB,CAAnBA;AADF,aAAA,MAEO;AACLA,cAAAA,gBAAgB,GAAG,CAAA,GAAA,MAAA,CAAA,SAAA,CAAA,EAAA,gBAAA,EAAnBA,SAAmB,CAAnBA;AATiC,aAAA,CAYnC;;;AACAT,YAAAA,wBAAwB,GAAGE,eAAe,CAAfA,OAAAA,CAA3BF,KAA2BE,CAA3BF;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,aAAA;AAAgC;AAC9B;AACA;AACAmF,YAAAA,iBAAiB,GAAGQ,YAAY,CAHF,KAG9BR,CAH8B,CAI9B;;AACApB,YAAAA,wBAAwB,GAAxBA,QAAAA;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,cAAA;AAAiC;AAC/B;AACA;AACA,gBAAM8C,MAAK,GAAGmB,eAAe,CAAfA,OAAAA,CAAwB0B,YAAY,CAAlD,QAAc1B,CAAd;;AACA,gBAAInB,MAAK,KAAK,CAAd,CAAA,EAAkBqC,iBAAiB,GAAjBA,MAAAA;AAClBpB,YAAAA,wBAAwB,GAAxBA,QAAAA;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,KAAA;AAAwB;AACtB;AACAiE,YAAAA,eAAe,GAAG,CAAA,GAAA,WAAA,CAAA,SAAA,CAAA,EAAA,eAAA,EAAlBA,gBAAkB,CAAlBA;AACAO,YAAAA,gBAAgB,GAAhBA,EAAAA;AACAW,YAAAA,iBAAiB,GAAGe,IAAI,CAAJA,GAAAA,CAAAA,iBAAAA,EAElBjC,eAAe,CAAfA,MAAAA,GAFFkB,CAAoBe,CAApBf;AAIA;AACD;;AACD,aAAKnF,WAAW,CAAhB,cAAA;AAAiC;AAC/B;AACA,gBAAM2C,UAAQ,GAAGgD,YAAY,CAA7B,QAAA;AACA,gBAAMQ,GAAG,GAAGlC,eAAe,CAAfA,OAAAA,CAHmB,UAGnBA,CAAZ,CAH+B,CAI/B;;AACA,gBAAIkC,GAAG,GAAP,CAAA,EAAa;AACb,gBAAMvD,cAAc,GAAG+C,YAAY,CAAnC,cAAA;AACA,gBAAIS,MAAM,GAAGnC,eAAe,CAAfA,OAAAA,CAAb,cAAaA,CAAb;;AACA,gBAAImC,MAAM,GAAV,CAAA,EAAgB;AACd;AACA,kBAAMC,KAAK,GAAGpC,eAAe,CAA7B,MAAA;AACAmC,cAAAA,MAAM,GAAGxD,cAAc,GAAGqB,eAAe,CAACoC,KAAK,GAAtCzD,CAAgC,CAAhCA,GAAAA,KAAAA,GAATwD,CAAAA;AACD;;AACD,gBAAME,IAAI,GAAGH,GAAG,GAAhB,MAAA;;AAEA,gBAAIG,IAAI,GAAR,CAAA,EAAc;AACZ;AACArC,cAAAA,eAAe,GAAA,GAAA,MAAA,CAAA,kBAAA,CACVA,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EADU,MACVA,CADU,CAAA,EAAA,CAAA,UAAA,CAAA,EAAA,kBAAA,CAGVA,eAAe,CAAfA,KAAAA,CAAAA,MAAAA,EAHU,GAGVA,CAHU,CAAA,EAAA,kBAAA,CAIVA,eAAe,CAAfA,KAAAA,CAAsBkC,GAAG,GAJ9BlC,CAIKA,CAJU,CAAA,CAAfA;AAMAF,cAAAA,wBAAwB,GAAxBA,MAAAA;AARF,aAAA,MASO,IAAIuC,IAAI,GAAR,CAAA,EAAc;AACnB;AACArC,cAAAA,eAAe,GAAA,GAAA,MAAA,CAAA,kBAAA,CACVA,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EADU,GACVA,CADU,CAAA,EAAA,kBAAA,CAEVA,eAAe,CAAfA,KAAAA,CAAsBkC,GAAG,GAAzBlC,CAAAA,EAFU,MAEVA,CAFU,CAAA,EAAA,CAAA,UAAA,CAAA,EAAA,kBAAA,CAIVA,eAAe,CAAfA,KAAAA,CAJLA,MAIKA,CAJU,CAAA,CAAfA;AAMAF,cAAAA,wBAAwB,GAAxBA,GAAAA;AACD;;AACD;AACD;;AACD,aAAK/D,WAAW,CAAhB,YAAA;AAA+B;AAC7B,gBAAIuG,OAAO,CAACZ,YAAY,CAAxB,eAAW,CAAX,EAA2C;AACzC;AACAvB,cAAAA,WAAW,GAAG;AAAE,mBAAGa,UAAU,CAAA,WAAA;AAAf,eAAdb;AACAY,cAAAA,YAAY,GAAZA,CAAAA;AACAf,cAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,cAAAA,gBAAgB,GAAhBA,EAAAA;AACAW,cAAAA,iBAAiB,GAAGQ,YAAY,CAAZA,eAAAA,CAApBR,MAAAA;AACAnB,cAAAA,cAAc,GAAdA,EAAAA;AACAkB,cAAAA,cAAc,GAAGS,YAAY,CAA7BT,cAAAA;AACAnB,cAAAA,wBAAwB,GATiB,CASzCA,CATyC,CAUzC;;AACA4B,cAAAA,YAAY,CAAZA,eAAAA,CAAAA,OAAAA,CAAqC,UAAA,MAAA,EAAY;AAC/CvB,gBAAAA,WAAW,CAAXA,YAAW,CAAXA,GAA4Ba,UAAU,CAAA,MAAA,EAEpCI,OAAO,CAAPA,KAAAA,IAAiBA,OAAO,CAF1BjB,sBAAsC,CAAtCA;AAIAH,gBAAAA,eAAe,CAAfA,IAAAA,CAAAA,YAAAA;AACAe,gBAAAA,YAAY;AANdW,eAAAA;AAXF,aAAA,MAmBO;AACL;AADK,kBAAA,qBAAA,GAWDA,YAAY,CAXX,eAAA;AAGHb,cAAAA,YAHG,GAAA,qBAAA,CAAA,YAGHA;AACAV,cAAAA,WAJG,GAAA,qBAAA,CAAA,WAIHA;AACAY,cAAAA,YALG,GAAA,qBAAA,CAAA,YAKHA;AACAf,cAAAA,eANG,GAAA,qBAAA,CAAA,eAMHA;AACAO,cAAAA,gBAPG,GAAA,qBAAA,CAAA,gBAOHA;AACAU,cAAAA,cARG,GAAA,qBAAA,CAAA,cAQHA;AACAC,cAAAA,iBATG,GAAA,qBAAA,CAAA,iBASHA;AACAnB,cAAAA,cAVG,GAAA,qBAAA,CAAA,cAUHA;;AAGF,kBAAI2B,YAAY,CAAhB,WAAA,EAA8B;AAC5B5B,gBAAAA,wBAAwB,GAAxBA,QAAAA;AACD;AACF;;AAED;AACD;;AACD,aAAK/D,WAAW,CAAhB,YAAA;AAA+B;AAC7BoF,YAAAA,QAAQ,GAAGO,YAAY,CAAvBP,MAAAA;AACArB,YAAAA,wBAAwB,GAAxBA,QAAAA;AACA;AACD;;AACD,aAAK/D,WAAW,CAAhB,eAAA;AAAkC;AAChCsF,YAAAA,QAAQ,GAAGK,YAAY,CAAvBL,MAAAA;;AACA,gBAAA,QAAA,EAAc;AACZ,qBAAOU,mBAAmB,CAA1B,IAA0B,CAA1B;AAH8B,aAAA,CAKhC;;;AACA5B,YAAAA,WAAW,GAAG;AAAE,iBAAGa,UAAU,CAAA,WAAA;AAAf,aAAdb;AACAY,YAAAA,YAAY,GAAZA,CAAAA;AACAf,YAAAA,eAAe,GAAG,CAAlBA,CAAkB,CAAlBA;AACAO,YAAAA,gBAAgB,GAAhBA,EAAAA;AACAU,YAAAA,cAAc,GAAGlB,cAAc,CAAdA,iBAAc,CAAdA,CAAjBkB,KAAAA;AACAC,YAAAA,iBAAiB,GAAjBA,CAAAA;AACAnB,YAAAA,cAAc,GAAdA,EAAAA;AACA;AACD;;AACD;AAAS;AACP;AACA;AACAD,YAAAA,wBAAwB,GAAxBA,QAAAA;AACA;AACD;AArNH;AAuND;;AAEDC,IAAAA,cAAc,GAAG8B,eAAe,CAAA,cAAA,EAAA,wBAAA,EAAA,OAAA,EAAA,cAAA,EAAA,WAAA,EAAA,eAAA,EAAA,gBAAA,EAQ9BT,OAAO,CARTrB,iBAAgC,CAAhCA;AAUAc,IAAAA,YAAY,GAAGC,cAAc,CAAA,YAAA,EAA7BD,YAA6B,CAA7BA;AACA,WAAO;AACLA,MAAAA,YAAY,EADP,YAAA;AAELV,MAAAA,WAAW,EAFN,WAAA;AAGLY,MAAAA,YAAY,EAHP,YAAA;AAILf,MAAAA,eAAe,EAJV,eAAA;AAKLO,MAAAA,gBAAgB,EALX,gBAAA;AAMLU,MAAAA,cAAc,EANT,cAAA;AAOLC,MAAAA,iBAAiB,EAPZ,iBAAA;AAQLnB,MAAAA,cAAc,EART,cAAA;AASLoB,MAAAA,QAAQ,EATH,QAAA;AAULE,MAAAA,QAAQ,EAARA;AAVK,KAAP;AA/XF,GAAA;AA4YD;AAED;;;;;AAGO,SAAA,WAAA,CAAA,WAAA,EAOa;AAAA,MACVtB,cADU,GAC4BuB,WAD5B,CAAA,cAAA;AAAA,MACMJ,iBADN,GAC4BI,WAD5B,CAAA,iBAAA;AAAA,MAEV1B,KAFU,GAEAG,cAAc,CAFd,iBAEc,CAAdA,CAFA,KAAA;AAGlB,SAAA,KAAA;AACD;AAsBD;;;;;AAGO,SAAA,WAAA,CAAA,WAAA,EAAA,WAAA,EAAA,OAAA,EAeL;AACA,MAAA,gBAAA;AACA,MAAMzC,KAAK,GAAG8D,OAAO,CAAPA,KAAAA,IAAiBA,OAAO,CAAtC,sBAAA;AACA,MAAM3D,UAAU,GAAG2D,OAAO,CAAPA,UAAAA,IAAnB,EAAA;;AAEA,WAAA,QAAA,GAAsC;AACpC,QAAMxB,KAAK,GAAG2C,WAAW,CACvBC,WAAW,CADb,QACEA,EADuB,CAAzB;;AAGA,QAAI5C,KAAK,KAAT,SAAA,EAAyB;AACvB6C,MAAAA,gBAAgB,GAAhBA,KAAAA;AACD;;AACD,WAAA,gBAAA;AACD;;AAED,WAAA,QAAA,CAAA,MAAA,EAA6C;AAC3CD,IAAAA,WAAW,CAAXA,QAAAA,CAAqBxB,UAAU,CAAA,MAAA,EAAA,KAAA,EAAA,UAAA,EAA/BwB,QAA+B,CAA/BA;AACA,WAAA,MAAA;AACD;;AAED,SAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,WAAA,CAAA,EAAA,EAAA,EAAA,eAAA,CAAA;AAGEA,IAAAA,WAAW,EAHb,WAAA;AAKEE,IAAAA,QAAQ,EALV,QAAA;AAOEC,IAAAA,QAAQ,EAPV,QAAA;AASEC,IAAAA,cATF,EAAA,SAAA,cAAA,CAAA,WAAA,EAS4D;AACxDJ,MAAAA,WAAW,CAAXA,cAAAA,CACGK,WAAW,CADdL,WACc,CADdA;AAQD;AAlBH,GAAA,EAoBGM,iBAAAA,CApBH,SAoBGA,CApBH,EAAA,YAoBkC;AAC9B,WAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EACMN,WAAD,CAAqBM,iBAAAA,CAD1B,SAC0BA,CAArB,CAACN,EADN,CAAA,EAAA,EAAA,EAAA,eAAA,CAAA;AAEEO,MAAAA,SAFF,EAAA,SAAA,SAAA,CAAA,QAAA,EAEsB;AAClB,YAAI,OAAA,CAAA,QAAA,CAAA,KAAJ,QAAA,EAAkC;AAChC,gBAAM,IAAA,SAAA,CAAN,wCAAM,CAAN;AACD;;AAED,iBAAA,YAAA,GAAwB;AACtB,cAAIC,QAAQ,CAAZ,IAAA,EAAmB;AACjBA,YAAAA,QAAQ,CAARA,IAAAA,CAAcL,QAAdK,EAAAA;AACD;AACF;;AAEDC,QAAAA,YAAY;AACZ,YAAMC,WAAW,GAAGV,WAAW,CAAXA,SAAAA,CAApB,YAAoBA,CAApB;AACA,eAAO;AAAEU,UAAAA,WAAW,EAAXA;AAAF,SAAP;AACD;AAhBH,KAAA,EAkBGJ,iBAAAA,CAlBH,SAkBGA,CAlBH,EAAA,YAkBmB;AACf,aAAA,IAAA;AAnBJ,KAAA,CAAA,CAAA;AArBJ,GAAA,CAAA,CAAA;AAmDD;AAwBD;;;;;AAGe,SAAA,UAAA,GASyC;AAAA,MAHtDhC,cAGsD,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAHG,YAAA;AAAA,WAAA,IAAA;AAGH,GAAA;AAAA,MADtDM,OACsD,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADc,EACd;;AACtD,MAAI,OAAOA,OAAO,CAAd,MAAA,KAAA,QAAA,IAAsCA,OAAO,CAAPA,MAAAA,GAA1C,CAAA,EAA8D;AAC5D,UAAM,IAAA,KAAA,CACJ,2DADF,yBAAM,CAAN;AAID;;AAED,SAAO,UAAA,WAAA,EAAA;AAAA,WAEF,UAAA,OAAA,EAAA,YAAA,EAGA;AACH,eAAA,WAAA,CAAA,CAAA,EAAuC;AACrC,YAAI,OAAA,CAAA,KAAJ,UAAA,EAA6B;AAC3B,cAAI+B,CAAC,IAAI,OAAQA,CAAD,CAAP,SAAO,CAAP,KAAT,UAAA,EAAoE;AAClE,kBAAM,IAAA,KAAA,CACJ,4CAAA,gDAAA,GAAA,uDAAA,GADF,2CAAM,CAAN;AAMD;;AACD,gBAAM,IAAA,KAAA,CAAN,wCAAM,CAAN;AACD;;AACD,eAAOC,eAAe,CAAA,CAAA,EAAA,YAAA,EAAA,cAAA,EAAtB,OAAsB,CAAtB;AAMD;;AAED,UAAMZ,WAAW,GAAGa,WAAW,CAACR,WAAW,CAA3C,OAA2C,CAAZ,CAA/B;;AACA,UACGL,WAAD,CADF,WAAA,EAWE;AACA,cAAM,IAAA,KAAA,CACJ,oEADF,iCAAM,CAAN;AAID;;AAED,aAAOc,WAAW,CAAA,WAAA,EAAA,WAAA,EAAlB,OAAkB,CAAlB;AA7CK,KAAA;AAAP,GAAA;AA0DD","sourcesContent":["import difference from 'lodash/difference';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport $$observable from 'symbol-observable';\nimport {\n  Action,\n  Observable,\n  PreloadedState,\n  Reducer,\n  Store,\n  StoreEnhancer,\n  StoreEnhancerStoreCreator,\n} from 'redux';\n\nexport const ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING',\n} as const;\n\nconst isChrome =\n  typeof window === 'object' &&\n  (typeof (window as typeof window & { chrome: unknown }).chrome !==\n    'undefined' ||\n    (typeof window.process !== 'undefined' &&\n      (window.process as typeof window.process & { type: unknown }).type ===\n        'renderer'));\n\nconst isChromeOrNode =\n  isChrome ||\n  (typeof process !== 'undefined' &&\n    process.release &&\n    process.release.name === 'node');\n\nexport interface PerformAction<A extends Action<unknown>> {\n  type: typeof ActionTypes.PERFORM_ACTION;\n  action: A;\n  timestamp: number;\n  stack: string | undefined;\n}\n\ninterface ResetAction {\n  type: typeof ActionTypes.RESET;\n  timestamp: number;\n}\n\ninterface RollbackAction {\n  type: typeof ActionTypes.ROLLBACK;\n  timestamp: number;\n}\n\ninterface CommitAction {\n  type: typeof ActionTypes.COMMIT;\n  timestamp: number;\n}\n\ninterface SweepAction {\n  type: typeof ActionTypes.SWEEP;\n}\n\ninterface ToggleAction {\n  type: typeof ActionTypes.TOGGLE_ACTION;\n  id: number;\n}\n\ninterface SetActionsActiveAction {\n  type: typeof ActionTypes.SET_ACTIONS_ACTIVE;\n  start: number;\n  end: number;\n  active: boolean;\n}\n\ninterface ReorderAction {\n  type: typeof ActionTypes.REORDER_ACTION;\n  actionId: number;\n  beforeActionId: number;\n}\n\ninterface JumpToStateAction {\n  type: typeof ActionTypes.JUMP_TO_STATE;\n  index: number;\n}\n\ninterface JumpToActionAction {\n  type: typeof ActionTypes.JUMP_TO_ACTION;\n  actionId: number;\n}\n\ninterface ImportStateAction<S, A extends Action<unknown>, MonitorState> {\n  type: typeof ActionTypes.IMPORT_STATE;\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[];\n  preloadedState?: S;\n  noRecompute: boolean | undefined;\n}\n\ninterface LockChangesAction {\n  type: typeof ActionTypes.LOCK_CHANGES;\n  status: boolean;\n}\n\ninterface PauseRecordingAction {\n  type: typeof ActionTypes.PAUSE_RECORDING;\n  status: boolean;\n}\n\nexport type LiftedAction<S, A extends Action<unknown>, MonitorState> =\n  | PerformAction<A>\n  | ResetAction\n  | RollbackAction\n  | CommitAction\n  | SweepAction\n  | ToggleAction\n  | SetActionsActiveAction\n  | ReorderAction\n  | JumpToStateAction\n  | JumpToActionAction\n  | ImportStateAction<S, A, MonitorState>\n  | LockChangesAction\n  | PauseRecordingAction;\n\n/**\n * Action creators to change the History state.\n */\nexport const ActionCreators = {\n  performAction<A extends Action<unknown>>(\n    action: A,\n    trace?: ((action: A) => string | undefined) | boolean,\n    traceLimit?: number,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    toExcludeFromTrace?: Function\n  ) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      );\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n\n    let stack;\n    if (trace) {\n      let extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        const error = Error();\n        let prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (\n          extraFrames ||\n          typeof Error.stackTraceLimit !== 'number' ||\n          (traceLimit && Error.stackTraceLimit > traceLimit)\n        ) {\n          if (stack != null) {\n            const frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames\n                .slice(\n                  0,\n                  traceLimit +\n                    extraFrames +\n                    (frames[0].startsWith('Error') ? 1 : 0)\n                )\n                .join('\\n');\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action,\n      timestamp: Date.now(),\n      stack,\n    };\n  },\n\n  reset(): ResetAction {\n    return { type: ActionTypes.RESET, timestamp: Date.now() };\n  },\n\n  rollback(): RollbackAction {\n    return { type: ActionTypes.ROLLBACK, timestamp: Date.now() };\n  },\n\n  commit(): CommitAction {\n    return { type: ActionTypes.COMMIT, timestamp: Date.now() };\n  },\n\n  sweep(): SweepAction {\n    return { type: ActionTypes.SWEEP };\n  },\n\n  toggleAction(id: number): ToggleAction {\n    return { type: ActionTypes.TOGGLE_ACTION, id };\n  },\n\n  setActionsActive(\n    start: number,\n    end: number,\n    active = true\n  ): SetActionsActiveAction {\n    return { type: ActionTypes.SET_ACTIONS_ACTIVE, start, end, active };\n  },\n\n  reorderAction(actionId: number, beforeActionId: number): ReorderAction {\n    return { type: ActionTypes.REORDER_ACTION, actionId, beforeActionId };\n  },\n\n  jumpToState(index: number): JumpToStateAction {\n    return { type: ActionTypes.JUMP_TO_STATE, index };\n  },\n\n  jumpToAction(actionId: number): JumpToActionAction {\n    return { type: ActionTypes.JUMP_TO_ACTION, actionId };\n  },\n\n  importState<S, A extends Action<unknown>, MonitorState = null>(\n    nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[],\n    noRecompute?: boolean\n  ): ImportStateAction<S, A, MonitorState> {\n    return { type: ActionTypes.IMPORT_STATE, nextLiftedState, noRecompute };\n  },\n\n  lockChanges(status: boolean): LockChangesAction {\n    return { type: ActionTypes.LOCK_CHANGES, status };\n  },\n\n  pauseRecording(status: boolean): PauseRecordingAction {\n    return { type: ActionTypes.PAUSE_RECORDING, status };\n  },\n};\n\nexport const INIT_ACTION = { type: '@@INIT' };\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S\n) {\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(() => {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S,\n  shouldCatchErrors: boolean | undefined\n) {\n  if (!shouldCatchErrors) {\n    return { state: reducer(state, action) };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates<S, A extends Action<unknown>>(\n  computedStates: { state: S; error?: string }[],\n  minInvalidatedStateIndex: number,\n  reducer: Reducer<S, A>,\n  committedState: S,\n  actionsById: { [actionId: number]: PerformAction<A> },\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  shouldCatchErrors: boolean | undefined\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    !computedStates ||\n    minInvalidatedStateIndex === -1 ||\n    (minInvalidatedStateIndex >= computedStates.length &&\n      computedStates.length === stagedActionIds.length)\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    let entry;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain',\n        };\n      } else {\n        entry = computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          shouldCatchErrors\n        );\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction<A extends Action<unknown>>(\n  action: A,\n  trace?: ((action: A) => string | undefined) | boolean,\n  traceLimit?: number,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace?: Function\n) {\n  return ActionCreators.performAction(\n    action,\n    trace,\n    traceLimit,\n    toExcludeFromTrace\n  );\n}\n\nfunction isArray<S, A extends Action<unknown>, MonitorState>(\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[]\n): nextLiftedState is readonly A[] {\n  return Array.isArray(nextLiftedState);\n}\n\nexport interface LiftedState<S, A extends Action<unknown>, MonitorState> {\n  monitorState: MonitorState;\n  nextActionId: number;\n  actionsById: { [actionId: number]: PerformAction<A> };\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: S;\n  currentStateIndex: number;\n  computedStates: { state: S; error?: string }[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n>(\n  reducer: Reducer<S, A>,\n  initialCommittedState: PreloadedState<S> | undefined,\n  monitorReducer: Reducer<MonitorState, MonitorAction>,\n  options: Options<S, A, MonitorState, MonitorAction>\n): Reducer<LiftedState<S, A, MonitorState>, LiftedAction<S, A, MonitorState>> {\n  const initialLiftedState: LiftedState<S, A, MonitorState> = {\n    monitorState: monitorReducer(undefined, {} as MonitorAction),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION as A) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState as S,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false,\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    liftedState: LiftedState<S, A, MonitorState> | undefined,\n    liftedAction: LiftedAction<S, A, MonitorState>\n  ): LiftedState<S, A, MonitorState> => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = { ...actionsById };\n    }\n\n    function commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        (id) => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(\n      shouldInit?: boolean\n    ): LiftedState<S, A, MonitorState> {\n      let computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(\n          monitorState,\n          liftedAction as MonitorAction\n        );\n      } else {\n        computedState = computeNextEntry(\n          reducer,\n          (liftedAction as PerformAction<A>).action,\n          computedStates[currentStateIndex].state,\n          false\n        );\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState,\n          actionsById: { 0: liftAction(INIT_ACTION as A) },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked,\n          isPaused: true,\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [...stagedActionIds, nextActionId];\n        nextActionId++;\n      }\n      return {\n        monitorState,\n        actionsById: {\n          ...actionsById,\n          [nextActionId - 1]: liftAction({\n            type: options.pauseActionType,\n          } as A),\n        },\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates: [\n          ...computedStates.slice(0, stagedActionIds.length - 1),\n          computedState,\n        ],\n        isLocked,\n        isPaused: true,\n      };\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    let maxAge = options.maxAge;\n    if (typeof maxAge === 'function')\n      maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = { 0: liftAction(INIT_ACTION as A) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState =\n          computedStates.length === 0\n            ? (initialCommittedState as S)\n            : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates<S, A>(\n          computedStates,\n          minInvalidatedStateIndex,\n          reducer,\n          committedState,\n          actionsById,\n          stagedActionIds,\n          skippedActionIds,\n          options.shouldCatchErrors\n        );\n\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION: {\n          if (isLocked) return liftedState || initialLiftedState;\n          if (isPaused) return computePausedAction();\n\n          // Auto-commit as new actions come in.\n          if (maxAge && stagedActionIds.length >= maxAge) {\n            commitExcessActions(stagedActionIds.length - maxAge + 1);\n          }\n\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n        case ActionTypes.RESET: {\n          // Get back to the state the store was created with.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState as S;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.COMMIT: {\n          // Consider the last committed state the new starting point.\n          // Squash any staged actions into a single committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.ROLLBACK: {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.TOGGLE_ACTION: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { id: actionId } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n        case ActionTypes.SET_ACTIONS_ACTIVE: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { start, end, active } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = union(skippedActionIds, actionIds);\n          }\n\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n        case ActionTypes.JUMP_TO_STATE: {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.JUMP_TO_ACTION: {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.SWEEP: {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(\n            currentStateIndex,\n            stagedActionIds.length - 1\n          );\n          break;\n        }\n        case ActionTypes.REORDER_ACTION: {\n          // Recompute actions in a new order.\n          const actionId = liftedAction.actionId;\n          const idx = stagedActionIds.indexOf(actionId);\n          // do nothing in case the action is already removed or trying to move the first action\n          if (idx < 1) break;\n          const beforeActionId = liftedAction.beforeActionId;\n          let newIdx = stagedActionIds.indexOf(beforeActionId);\n          if (newIdx < 1) {\n            // move to the beginning or to the end\n            const count = stagedActionIds.length;\n            newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n          }\n          const diff = idx - newIdx;\n\n          if (diff > 0) {\n            // move left\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx, idx),\n              ...stagedActionIds.slice(idx + 1),\n            ];\n            minInvalidatedStateIndex = newIdx;\n          } else if (diff < 0) {\n            // move right\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, idx),\n              ...stagedActionIds.slice(idx + 1, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx),\n            ];\n            minInvalidatedStateIndex = idx;\n          }\n          break;\n        }\n        case ActionTypes.IMPORT_STATE: {\n          if (isArray(liftedAction.nextLiftedState)) {\n            // recompute array of actions\n            actionsById = { 0: liftAction(INIT_ACTION as A) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = liftedAction.nextLiftedState.length;\n            computedStates = [];\n            committedState = liftedAction.preloadedState as S;\n            minInvalidatedStateIndex = 0;\n            // iterate through actions\n            liftedAction.nextLiftedState.forEach((action) => {\n              actionsById[nextActionId] = liftAction(\n                action,\n                options.trace || options.shouldIncludeCallstack\n              );\n              stagedActionIds.push(nextActionId);\n              nextActionId++;\n            });\n          } else {\n            // Completely replace everything.\n            ({\n              monitorState,\n              actionsById,\n              nextActionId,\n              stagedActionIds,\n              skippedActionIds,\n              committedState,\n              currentStateIndex,\n              computedStates,\n            } = liftedAction.nextLiftedState);\n\n            if (liftedAction.noRecompute) {\n              minInvalidatedStateIndex = Infinity;\n            }\n          }\n\n          break;\n        }\n        case ActionTypes.LOCK_CHANGES: {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.PAUSE_RECORDING: {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            return computePausedAction(true);\n          }\n          // Commit when unpausing\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        default: {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds,\n      options.shouldCatchErrors\n    );\n    monitorState = monitorReducer(monitorState, liftedAction as MonitorAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  NextStateExt\n>(\n  liftedState: LiftedState<S, A, MonitorState> & NextStateExt\n): S & NextStateExt {\n  const { computedStates, currentStateIndex } = liftedState;\n  const { state } = computedStates[currentStateIndex];\n  return state as S & NextStateExt;\n}\n\nexport type LiftedReducer<S, A extends Action<unknown>, MonitorState> = Reducer<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type LiftedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type InstrumentExt<S, A extends Action<unknown>, MonitorState> = {\n  liftedStore: LiftedStore<S, A, MonitorState>;\n};\n\nexport type EnhancedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  S,\n  A\n> &\n  InstrumentExt<S, A, MonitorState>;\n\n/**\n * Provides an app's view into the lifted store.\n */\nexport function unliftStore<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>,\n  NextExt,\n  NextStateExt\n>(\n  liftedStore: Store<\n    LiftedState<S, A, MonitorState> & NextStateExt,\n    LiftedAction<S, A, MonitorState>\n  > &\n    NextExt,\n  liftReducer: (r: Reducer<S, A>) => LiftedReducer<S, A, MonitorState>,\n  options: Options<S, A, MonitorState, MonitorAction>\n) {\n  let lastDefinedState: S & NextStateExt;\n  const trace = options.trace || options.shouldIncludeCallstack;\n  const traceLimit = options.traceLimit || 10;\n\n  function getState(): S & NextStateExt {\n    const state = unliftState<S, A, MonitorState, NextStateExt>(\n      liftedStore.getState()\n    );\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n\n  function dispatch<T extends A>(action: T): T {\n    liftedStore.dispatch(liftAction<A>(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return ({\n    ...liftedStore,\n\n    liftedStore,\n\n    dispatch,\n\n    getState,\n\n    replaceReducer(nextReducer: Reducer<S & NextStateExt, A>) {\n      liftedStore.replaceReducer(\n        (liftReducer(\n          (nextReducer as unknown) as Reducer<S, A>\n        ) as unknown) as Reducer<\n          LiftedState<S, A, MonitorState> & NextStateExt,\n          LiftedAction<S, A, MonitorState>\n        >\n      );\n    },\n\n    [$$observable](): Observable<S> {\n      return {\n        ...(liftedStore as any)[$$observable](),\n        subscribe(observer) {\n          if (typeof observer !== 'object') {\n            throw new TypeError('Expected the observer to be an object.');\n          }\n\n          function observeState() {\n            if (observer.next) {\n              observer.next(getState());\n            }\n          }\n\n          observeState();\n          const unsubscribe = liftedStore.subscribe(observeState);\n          return { unsubscribe };\n        },\n\n        [$$observable]() {\n          return this;\n        },\n      };\n    },\n  } as unknown) as Store<S & NextStateExt, A> &\n    NextExt & {\n      liftedStore: Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      >;\n    };\n}\n\nexport interface Options<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n> {\n  maxAge?:\n    | number\n    | ((\n        currentLiftedAction: LiftedAction<S, A, MonitorState>,\n        previousLiftedState: LiftedState<S, A, MonitorState> | undefined\n      ) => number);\n  shouldCatchErrors?: boolean;\n  shouldRecordChanges?: boolean;\n  pauseActionType?: unknown;\n  shouldStartLocked?: boolean;\n  shouldHotReload?: boolean;\n  trace?: boolean | ((action: A) => string | undefined);\n  traceLimit?: number;\n  shouldIncludeCallstack?: boolean;\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nexport default function instrument<\n  OptionsS,\n  OptionsA extends Action<unknown>,\n  MonitorState = null,\n  MonitorAction extends Action<unknown> = never\n>(\n  monitorReducer: Reducer<MonitorState, MonitorAction> = ((() =>\n    null) as unknown) as Reducer<MonitorState, MonitorAction>,\n  options: Options<OptionsS, OptionsA, MonitorState, MonitorAction> = {}\n): StoreEnhancer<InstrumentExt<any, any, MonitorState>> {\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error(\n      'DevTools.instrument({ maxAge }) option, if specified, ' +\n        'may not be less than 2.'\n    );\n  }\n\n  return <NextExt, NextStateExt>(\n    createStore: StoreEnhancerStoreCreator<NextExt, NextStateExt>\n  ) => <S, A extends Action<unknown>>(\n    reducer: Reducer<S, A>,\n    initialState?: PreloadedState<S>\n  ) => {\n    function liftReducer(r: Reducer<S, A>) {\n      if (typeof r !== 'function') {\n        if (r && typeof (r as { default: unknown }).default === 'function') {\n          throw new Error(\n            'Expected the reducer to be a function. ' +\n              'Instead got an object with a \"default\" field. ' +\n              'Did you pass a module instead of the default export? ' +\n              'Try passing require(...).default instead.'\n          );\n        }\n        throw new Error('Expected the reducer to be a function.');\n      }\n      return liftReducerWith<S, A, MonitorState, MonitorAction>(\n        r,\n        initialState,\n        monitorReducer,\n        (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n      );\n    }\n\n    const liftedStore = createStore(liftReducer(reducer));\n    if (\n      (liftedStore as Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      > &\n        NextExt & {\n          liftedStore: Store<\n            LiftedState<S, A, MonitorState>,\n            LiftedAction<S, A, MonitorState>\n          >;\n        }).liftedStore\n    ) {\n      throw new Error(\n        'DevTools instrumentation should not be applied more than once. ' +\n          'Check your store configuration.'\n      );\n    }\n\n    return unliftStore<\n      S,\n      A,\n      MonitorState,\n      MonitorAction,\n      NextExt,\n      NextStateExt\n    >(\n      liftedStore,\n      liftReducer,\n      (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n    );\n  };\n}\n"]},"metadata":{},"sourceType":"script"}