{"ast":null,"code":"import _slicedToArray from \"/Users/mikepatrenin/Downloads/ForksFinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { normalize, schema } from 'normalizr';\nimport { camelizeKeys } from 'humps'; // Extracts the next page URL from Github API response.\n\nconst getNextPageUrl = response => {\n  const link = response.headers.get('link');\n\n  if (!link) {\n    return null;\n  }\n\n  const nextLink = link.split(',').find(s => s.indexOf('rel=\"next\"') > -1);\n\n  if (!nextLink) {\n    return null;\n  }\n\n  return nextLink.trim().split(';')[0].slice(1, -1);\n};\n\nconst API_ROOT = 'https://api.github.com/'; // Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\n\nconst callApi = (endpoint, schema) => {\n  const fullUrl = endpoint.indexOf(API_ROOT) === -1 ? API_ROOT + endpoint : endpoint;\n  console.log(\"FULL URL IS \".concat(fullUrl));\n  return fetch(fullUrl).then(response => response.json().then(json => {\n    if (!response.ok) {\n      return Promise.reject(json);\n    }\n\n    const camelizedJson = camelizeKeys(json);\n    const nextPageUrl = getNextPageUrl(response);\n    return Object.assign({}, normalize(camelizedJson, schema), {\n      nextPageUrl\n    });\n  }));\n}; // We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n// GitHub's API may return results with uppercase letters while the query\n// doesn't contain any. For example, \"someuser\" could result in \"SomeUser\"\n// leading to a frozen UI as it wouldn't find \"someuser\" in the entities.\n// That's why we're forcing lower cases down there.\n\n\nconst userSchema = new schema.Entity('users', {}, {\n  idAttribute: user => user.login.toLowerCase()\n});\nconst repoSchema = new schema.Entity('repos', {\n  owner: userSchema\n}, {\n  idAttribute: repo => repo.fullName.toLowerCase()\n});\nconst forksSchema = new schema.Entity('forks', {\n  owner: userSchema,\n  repo: repoSchema\n}); // Schemas for Github API responses.\n\nexport const Schemas = {\n  USER: userSchema,\n  USER_ARRAY: [userSchema],\n  REPO: repoSchema,\n  REPO_ARRAY: [repoSchema],\n  FORKS: forksSchema,\n  FORKS_ARRAY: [forksSchema]\n}; // Action key that carries API call info interpreted by this Redux middleware.\n\nexport const CALL_API = 'Call API'; // A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\n\nexport default (store => next => action => {\n  const callAPI = action[CALL_API];\n\n  if (typeof callAPI === 'undefined') {\n    return next(action);\n  }\n\n  let endpoint = callAPI.endpoint;\n  const schema = callAPI.schema,\n        types = callAPI.types;\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState());\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.');\n  }\n\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.');\n  }\n\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.');\n  }\n\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.');\n  }\n\n  const actionWith = data => {\n    const finalAction = Object.assign({}, action, data);\n    delete finalAction[CALL_API];\n    return finalAction;\n  };\n\n  const _types = _slicedToArray(types, 3),\n        requestType = _types[0],\n        successType = _types[1],\n        failureType = _types[2];\n\n  next(actionWith({\n    type: requestType\n  }));\n  return callApi(endpoint, schema).then(response => next(actionWith({\n    response,\n    type: successType\n  })), error => next(actionWith({\n    type: failureType,\n    error: error.message || 'Something bad happened'\n  })));\n});","map":{"version":3,"sources":["/Users/mikepatrenin/Downloads/ForksFinder/src/middleware/api.js"],"names":["normalize","schema","camelizeKeys","getNextPageUrl","response","link","headers","get","nextLink","split","find","s","indexOf","trim","slice","API_ROOT","callApi","endpoint","fullUrl","console","log","fetch","then","json","ok","Promise","reject","camelizedJson","nextPageUrl","Object","assign","userSchema","Entity","idAttribute","user","login","toLowerCase","repoSchema","owner","repo","fullName","forksSchema","Schemas","USER","USER_ARRAY","REPO","REPO_ARRAY","FORKS","FORKS_ARRAY","CALL_API","store","next","action","callAPI","types","getState","Error","Array","isArray","length","every","type","actionWith","data","finalAction","requestType","successType","failureType","error","message"],"mappings":"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","sourcesContent":["import { normalize, schema } from 'normalizr'\nimport { camelizeKeys } from 'humps'\n\n// Extracts the next page URL from Github API response.\nconst getNextPageUrl = response => {\n  \n  const link = response.headers.get('link')\n  if (!link) {\n    return null\n  }\n\n  const nextLink = link.split(',').find(s => s.indexOf('rel=\"next\"') > -1)\n  if (!nextLink) {\n    return null\n  }\n\n  return nextLink.trim().split(';')[0].slice(1, -1)\n}\n\nconst API_ROOT = 'https://api.github.com/'\n\n// Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\nconst callApi = (endpoint, schema) => {\n  const fullUrl = (endpoint.indexOf(API_ROOT) === -1) ? API_ROOT + endpoint : endpoint\n  console.log(`FULL URL IS ${fullUrl}`)\n\n  return fetch(fullUrl)\n    .then(response =>\n      response.json().then(json => {\n        if (!response.ok) {\n          return Promise.reject(json)\n        }\n\n        const camelizedJson = camelizeKeys(json)\n        const nextPageUrl = getNextPageUrl(response)\n\n        return Object.assign({},\n          normalize(camelizedJson, schema),\n          { nextPageUrl }\n        )\n      })\n    )\n}\n\n// We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n\n// GitHub's API may return results with uppercase letters while the query\n// doesn't contain any. For example, \"someuser\" could result in \"SomeUser\"\n// leading to a frozen UI as it wouldn't find \"someuser\" in the entities.\n// That's why we're forcing lower cases down there.\n\nconst userSchema = new schema.Entity('users', {}, {\n  idAttribute: user => user.login.toLowerCase()\n})\n\nconst repoSchema = new schema.Entity('repos', {\n  owner: userSchema\n}, {\n  idAttribute: repo => repo.fullName.toLowerCase()\n})\n\nconst forksSchema = new schema.Entity('forks', {\n  owner: userSchema,\n  repo: repoSchema\n})\n\n// Schemas for Github API responses.\nexport const Schemas = {\n  USER: userSchema,\n  USER_ARRAY: [userSchema],\n  REPO: repoSchema,\n  REPO_ARRAY: [repoSchema],\n  FORKS: forksSchema,\n  FORKS_ARRAY: [forksSchema]\n}\n\n// Action key that carries API call info interpreted by this Redux middleware.\nexport const CALL_API = 'Call API'\n\n// A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\nexport default store => next => action => {\n  const callAPI = action[CALL_API]\n  if (typeof callAPI === 'undefined') {\n    return next(action)\n  }\n\n  let { endpoint } = callAPI\n  const { schema, types } = callAPI\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState())\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.')\n  }\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.')\n  }\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.')\n  }\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.')\n  }\n\n  const actionWith = data => {\n    const finalAction = Object.assign({}, action, data)\n    delete finalAction[CALL_API]\n    return finalAction\n  }\n\n  const [ requestType, successType, failureType ] = types\n  next(actionWith({ type: requestType }))\n\n  return callApi(endpoint, schema).then(\n    response => next(actionWith({\n      response,\n      type: successType\n    })),\n    error => next(actionWith({\n      type: failureType,\n      error: error.message || 'Something bad happened'\n    }))\n  )\n}\n"]},"metadata":{},"sourceType":"module"}