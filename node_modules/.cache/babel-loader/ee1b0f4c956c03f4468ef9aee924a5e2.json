{"ast":null,"code":"import _objectSpread from \"/Users/mikepatrenin/Downloads/ForksFinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Users/mikepatrenin/Downloads/ForksFinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport union from 'lodash/union'; // Creates a reducer managing pagination, given the action types to handle,\n// and a function telling how to extract the key from an action.\n\nvar paginate = function paginate(_ref) {\n  var types = _ref.types,\n      mapActionToKey = _ref.mapActionToKey;\n\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected types to be an array of three elements.');\n  }\n\n  if (!types.every(function (t) {\n    return typeof t === 'string';\n  })) {\n    throw new Error('Expected types to be strings.');\n  }\n\n  if (typeof mapActionToKey !== 'function') {\n    throw new Error('Expected mapActionToKey to be a function.');\n  }\n\n  var _types = _slicedToArray(types, 3),\n      requestType = _types[0],\n      successType = _types[1],\n      failureType = _types[2];\n\n  var updatePagination = function updatePagination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      isFetching: false,\n      nextPageUrl: undefined,\n      pageCount: 0,\n      ids: []\n    };\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n\n    switch (action.type) {\n      case requestType:\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isFetching: true\n        });\n\n      case successType:\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isFetching: false,\n          ids: union(state.ids, action.response.result),\n          nextPageUrl: action.response.nextPageUrl,\n          pageCount: state.pageCount + 1\n        });\n\n      case failureType:\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isFetching: false\n        });\n\n      default:\n        return state;\n    }\n  };\n\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n\n    // Update pagination by key\n    switch (action.type) {\n      case requestType:\n      case successType:\n      case failureType:\n        var key = mapActionToKey(action);\n\n        if (typeof key !== 'string') {\n          throw new Error('Expected key to be a string.');\n        }\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [key]: updatePagination(state[key], action)\n        });\n\n      default:\n        return state;\n    }\n  };\n};\n\nexport default paginate;","map":{"version":3,"sources":["/Users/mikepatrenin/Downloads/ForksFinder/src/reducers/paginate.js"],"names":["union","paginate","types","mapActionToKey","Array","isArray","length","Error","every","t","requestType","successType","failureType","updatePagination","state","isFetching","nextPageUrl","undefined","pageCount","ids","action","type","response","result","key"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,cAAlB,C,CAEA;AACA;;AACA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,OAA+B;AAAA,MAA5BC,KAA4B,QAA5BA,KAA4B;AAAA,MAArBC,cAAqB,QAArBA,cAAqB;;AAC9C,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAAD,IAAyBA,KAAK,CAACI,MAAN,KAAiB,CAA9C,EAAiD;AAC/C,UAAM,IAAIC,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACD,MAAI,CAACL,KAAK,CAACM,KAAN,CAAY,UAAAC,CAAC;AAAA,WAAI,OAAOA,CAAP,KAAa,QAAjB;AAAA,GAAb,CAAL,EAA8C;AAC5C,UAAM,IAAIF,KAAJ,CAAU,+BAAV,CAAN;AACD;;AACD,MAAI,OAAOJ,cAAP,KAA0B,UAA9B,EAA0C;AACxC,UAAM,IAAII,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAT6C,8BAWIL,KAXJ;AAAA,MAWtCQ,WAXsC;AAAA,MAWzBC,WAXyB;AAAA,MAWZC,WAXY;;AAa9C,MAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,GAKX;AAAA,QALYC,KAKZ,uEALoB;AAChCC,MAAAA,UAAU,EAAE,KADoB;AAEhCC,MAAAA,WAAW,EAAEC,SAFmB;AAGhCC,MAAAA,SAAS,EAAE,CAHqB;AAIhCC,MAAAA,GAAG,EAAE;AAJ2B,KAKpB;AAAA,QAAXC,MAAW;;AACZ,YAAQA,MAAM,CAACC,IAAf;AACE,WAAKX,WAAL;AACE,+CACKI,KADL;AAEEC,UAAAA,UAAU,EAAE;AAFd;;AAIF,WAAKJ,WAAL;AACE,+CACKG,KADL;AAEEC,UAAAA,UAAU,EAAE,KAFd;AAGEI,UAAAA,GAAG,EAAEnB,KAAK,CAACc,KAAK,CAACK,GAAP,EAAYC,MAAM,CAACE,QAAP,CAAgBC,MAA5B,CAHZ;AAIEP,UAAAA,WAAW,EAAEI,MAAM,CAACE,QAAP,CAAgBN,WAJ/B;AAKEE,UAAAA,SAAS,EAAEJ,KAAK,CAACI,SAAN,GAAkB;AAL/B;;AAOF,WAAKN,WAAL;AACE,+CACKE,KADL;AAEEC,UAAAA,UAAU,EAAE;AAFd;;AAIF;AACE,eAAOD,KAAP;AApBJ;AAsBD,GA5BD;;AA8BA,SAAO,YAAwB;AAAA,QAAvBA,KAAuB,uEAAf,EAAe;AAAA,QAAXM,MAAW;;AAC7B;AACA,YAAQA,MAAM,CAACC,IAAf;AACE,WAAKX,WAAL;AACA,WAAKC,WAAL;AACA,WAAKC,WAAL;AACE,YAAMY,GAAG,GAAGrB,cAAc,CAACiB,MAAD,CAA1B;;AACA,YAAI,OAAOI,GAAP,KAAe,QAAnB,EAA6B;AAC3B,gBAAM,IAAIjB,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,+CACKO,KADL;AAEE,WAACU,GAAD,GAAOX,gBAAgB,CAACC,KAAK,CAACU,GAAD,CAAN,EAAaJ,MAAb;AAFzB;;AAIF;AACE,eAAON,KAAP;AAbJ;AAeD,GAjBD;AAkBD,CA7DD;;AA+DA,eAAeb,QAAf","sourcesContent":["import union from 'lodash/union'\n\n// Creates a reducer managing pagination, given the action types to handle,\n// and a function telling how to extract the key from an action.\nconst paginate = ({ types, mapActionToKey }) => {\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected types to be an array of three elements.')\n  }\n  if (!types.every(t => typeof t === 'string')) {\n    throw new Error('Expected types to be strings.')\n  }\n  if (typeof mapActionToKey !== 'function') {\n    throw new Error('Expected mapActionToKey to be a function.')\n  }\n\n  const [ requestType, successType, failureType ] = types\n\n  const updatePagination = (state = {\n    isFetching: false,\n    nextPageUrl: undefined,\n    pageCount: 0,\n    ids: []\n  }, action) => {\n    switch (action.type) {\n      case requestType:\n        return {\n          ...state,\n          isFetching: true\n        }\n      case successType:\n        return {\n          ...state,\n          isFetching: false,\n          ids: union(state.ids, action.response.result),\n          nextPageUrl: action.response.nextPageUrl,\n          pageCount: state.pageCount + 1\n        }\n      case failureType:\n        return {\n          ...state,\n          isFetching: false\n        }\n      default:\n        return state\n    }\n  }\n\n  return (state = {}, action) => {\n    // Update pagination by key\n    switch (action.type) {\n      case requestType:\n      case successType:\n      case failureType:\n        const key = mapActionToKey(action)\n        if (typeof key !== 'string') {\n          throw new Error('Expected key to be a string.')\n        }\n        return {\n          ...state,\n          [key]: updatePagination(state[key], action)\n        }\n      default:\n        return state\n    }\n  }\n}\n\nexport default paginate\n"]},"metadata":{},"sourceType":"module"}