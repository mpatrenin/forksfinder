{"ast":null,"code":"import _slicedToArray from \"/Users/mikepatrenin/Downloads/ForksFinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { normalize, schema } from 'normalizr';\nimport { camelizeKeys } from 'humps'; // Extracts the next page URL from Github API response.\n\nvar getNextPageUrl = function getNextPageUrl(response) {\n  var link = response.headers.get('link');\n\n  if (!link) {\n    return null;\n  }\n\n  var nextLink = link.split(',').find(function (s) {\n    return s.indexOf('rel=\"next\"') > -1;\n  });\n\n  if (!nextLink) {\n    return null;\n  }\n\n  return nextLink.trim().split(';')[0].slice(1, -1);\n};\n\nvar API_ROOT = 'https://api.github.com/'; // Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\n\nvar callApi = function callApi(endpoint, schema) {\n  var fullUrl = endpoint.indexOf(API_ROOT) === -1 ? API_ROOT + endpoint : endpoint;\n  console.log(\"FULL URL IS \".concat(fullUrl));\n  return fetch(fullUrl).then(function (response) {\n    return response.json().then(function (json) {\n      if (!response.ok) {\n        return Promise.reject(json);\n      }\n\n      var camelizedJson = camelizeKeys(json);\n      var nextPageUrl = getNextPageUrl(response);\n      return Object.assign({}, normalize(camelizedJson, schema), {\n        nextPageUrl: nextPageUrl\n      });\n    });\n  });\n}; // We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n// GitHub's API may return results with uppercase letters while the query\n// doesn't contain any. For example, \"someuser\" could result in \"SomeUser\"\n// leading to a frozen UI as it wouldn't find \"someuser\" in the entities.\n// That's why we're forcing lower cases down there.\n\n\nvar userSchema = new schema.Entity('users', {}, {\n  idAttribute: function idAttribute(user) {\n    return user.login.toLowerCase();\n  }\n});\nvar repoSchema = new schema.Entity('repos', {\n  owner: userSchema\n}, {\n  idAttribute: function idAttribute(repo) {\n    return repo.fullName.toLowerCase();\n  }\n});\nvar forksSchema = new schema.Entity('forks', {\n  owner: userSchema,\n  repo: repoSchema\n}); // Schemas for Github API responses.\n\nexport var Schemas = {\n  USER: userSchema,\n  USER_ARRAY: [userSchema],\n  REPO: repoSchema,\n  REPO_ARRAY: [repoSchema],\n  FORKS: forksSchema,\n  FORKS_ARRAY: [forksSchema]\n}; // Action key that carries API call info interpreted by this Redux middleware.\n\nexport var CALL_API = 'Call API'; // A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\n\nexport default (function (store) {\n  return function (next) {\n    return function (action) {\n      var callAPI = action[CALL_API];\n\n      if (typeof callAPI === 'undefined') {\n        return next(action);\n      }\n\n      var endpoint = callAPI.endpoint;\n      var schema = callAPI.schema,\n          types = callAPI.types;\n\n      if (typeof endpoint === 'function') {\n        endpoint = endpoint(store.getState());\n      }\n\n      if (typeof endpoint !== 'string') {\n        throw new Error('Specify a string endpoint URL.');\n      }\n\n      if (!schema) {\n        throw new Error('Specify one of the exported Schemas.');\n      }\n\n      if (!Array.isArray(types) || types.length !== 3) {\n        throw new Error('Expected an array of three action types.');\n      }\n\n      if (!types.every(function (type) {\n        return typeof type === 'string';\n      })) {\n        throw new Error('Expected action types to be strings.');\n      }\n\n      var actionWith = function actionWith(data) {\n        var finalAction = Object.assign({}, action, data);\n        delete finalAction[CALL_API];\n        return finalAction;\n      };\n\n      var _types = _slicedToArray(types, 3),\n          requestType = _types[0],\n          successType = _types[1],\n          failureType = _types[2];\n\n      next(actionWith({\n        type: requestType\n      }));\n      return callApi(endpoint, schema).then(function (response) {\n        return next(actionWith({\n          response: response,\n          type: successType\n        }));\n      }, function (error) {\n        return next(actionWith({\n          type: failureType,\n          error: error.message || 'Something bad happened'\n        }));\n      });\n    };\n  };\n});","map":{"version":3,"sources":["/Users/mikepatrenin/Downloads/ForksFinder/src/middleware/api.js"],"names":["normalize","schema","camelizeKeys","getNextPageUrl","response","link","headers","get","nextLink","split","find","s","indexOf","trim","slice","API_ROOT","callApi","endpoint","fullUrl","console","log","fetch","then","json","ok","Promise","reject","camelizedJson","nextPageUrl","Object","assign","userSchema","Entity","idAttribute","user","login","toLowerCase","repoSchema","owner","repo","fullName","forksSchema","Schemas","USER","USER_ARRAY","REPO","REPO_ARRAY","FORKS","FORKS_ARRAY","CALL_API","store","next","action","callAPI","types","getState","Error","Array","isArray","length","every","type","actionWith","data","finalAction","requestType","successType","failureType","error","message"],"mappings":"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","sourcesContent":["import { normalize, schema } from 'normalizr'\nimport { camelizeKeys } from 'humps'\n\n// Extracts the next page URL from Github API response.\nconst getNextPageUrl = response => {\n  \n  const link = response.headers.get('link')\n  if (!link) {\n    return null\n  }\n\n  const nextLink = link.split(',').find(s => s.indexOf('rel=\"next\"') > -1)\n  if (!nextLink) {\n    return null\n  }\n\n  return nextLink.trim().split(';')[0].slice(1, -1)\n}\n\nconst API_ROOT = 'https://api.github.com/'\n\n// Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\nconst callApi = (endpoint, schema) => {\n  const fullUrl = (endpoint.indexOf(API_ROOT) === -1) ? API_ROOT + endpoint : endpoint\n  console.log(`FULL URL IS ${fullUrl}`)\n\n  return fetch(fullUrl)\n    .then(response =>\n      response.json().then(json => {\n        if (!response.ok) {\n          return Promise.reject(json)\n        }\n\n        const camelizedJson = camelizeKeys(json)\n        const nextPageUrl = getNextPageUrl(response)\n\n        return Object.assign({},\n          normalize(camelizedJson, schema),\n          { nextPageUrl }\n        )\n      })\n    )\n}\n\n// We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n\n// GitHub's API may return results with uppercase letters while the query\n// doesn't contain any. For example, \"someuser\" could result in \"SomeUser\"\n// leading to a frozen UI as it wouldn't find \"someuser\" in the entities.\n// That's why we're forcing lower cases down there.\n\nconst userSchema = new schema.Entity('users', {}, {\n  idAttribute: user => user.login.toLowerCase()\n})\n\nconst repoSchema = new schema.Entity('repos', {\n  owner: userSchema\n}, {\n  idAttribute: repo => repo.fullName.toLowerCase()\n})\n\nconst forksSchema = new schema.Entity('forks', {\n  owner: userSchema,\n  repo: repoSchema\n})\n\n// Schemas for Github API responses.\nexport const Schemas = {\n  USER: userSchema,\n  USER_ARRAY: [userSchema],\n  REPO: repoSchema,\n  REPO_ARRAY: [repoSchema],\n  FORKS: forksSchema,\n  FORKS_ARRAY: [forksSchema]\n}\n\n// Action key that carries API call info interpreted by this Redux middleware.\nexport const CALL_API = 'Call API'\n\n// A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\nexport default store => next => action => {\n  const callAPI = action[CALL_API]\n  if (typeof callAPI === 'undefined') {\n    return next(action)\n  }\n\n  let { endpoint } = callAPI\n  const { schema, types } = callAPI\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState())\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.')\n  }\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.')\n  }\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.')\n  }\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.')\n  }\n\n  const actionWith = data => {\n    const finalAction = Object.assign({}, action, data)\n    delete finalAction[CALL_API]\n    return finalAction\n  }\n\n  const [ requestType, successType, failureType ] = types\n  next(actionWith({ type: requestType }))\n\n  return callApi(endpoint, schema).then(\n    response => next(actionWith({\n      response,\n      type: successType\n    })),\n    error => next(actionWith({\n      type: failureType,\n      error: error.message || 'Something bad happened'\n    }))\n  )\n}\n"]},"metadata":{},"sourceType":"module"}